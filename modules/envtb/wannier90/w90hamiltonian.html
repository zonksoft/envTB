

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>envtb.wannier90.w90hamiltonian &mdash; EnvTB 1 documentation</title>
    
    <link rel="stylesheet" href="../../../static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../static/jquery.js"></script>
    <script type="text/javascript" src="../../../static/underscore.js"></script>
    <script type="text/javascript" src="../../../static/doctools.js"></script>
    <link rel="top" title="EnvTB 1 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">EnvTB 1 documentation</a> &raquo;</li>
          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for envtb.wannier90.w90hamiltonian</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Alle Funktionen durchtesten!!!! Sparse matrix Umstellung hat vl noch</span>
<span class="sd">Spuren hinterlassen</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">envtb</span> <span class="kn">import</span> <span class="n">general</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">cmath</span>
<span class="kn">from</span> <span class="nn">envtb.vasp</span> <span class="kn">import</span> <span class="n">poscar</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span>
<span class="kn">from</span> <span class="nn">matplotlib.path</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="kn">as</span> <span class="nn">patches</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">sparse</span>

<div class="viewcode-block" id="Hamiltonian"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian">[docs]</a><span class="k">class</span> <span class="nc">Hamiltonian</span><span class="p">:</span>
    
    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    TODO: durchschleifen der argumente bei bloch_eigenvalues etc. ist bloed. vl. argumente bei allen anderen</span>
<span class="sd">    mit *args und auf dokumentation von bloch_eigenvalues verweisen?</span>
<span class="sd">    TODO: unitcellcoordinates and numbers is used ambiguously</span>
<span class="sd">    TODO: performance: use in-place operations for numpy -=, +=, *= and consider numpy.fromfunction</span>
<span class="sd">    TODO: to ensure a variable is a numpy array: a = array(a, copy=False)</span>
<span class="sd">    TODO: REFACTOR REFACTOR REFACTOR</span>
<span class="sd">    TODO: sparse matrices: http://docs.scipy.org/doc/scipy/reference/sparse.html, </span>
<span class="sd">          http://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.eigs.html#scipy.sparse.linalg.eigs</span>
<span class="sd">    TODO: plots konsistenter zur aussenwelt machen, dh steuerung von aussen erlauben (mehrere</span>
<span class="sd">          plots uebereinander, nebeneinander etc.</span>
<span class="sd">    TODO: alles sparse + abgeleitete hamiltonians auf die alten verweisen,</span>
<span class="sd">          nicht explizit schreiben</span>
<span class="sd">    TODO: moeglichkeit zu einem output-logfile mit versionsnummer, zB</span>
<span class="sd">          mit globaler variable LOG</span>

<span class="sd">    TODO; die reihenfolge in create_supercell ist komisch, zB beruecksichtigt energy_shift schon die vergroesserung</span>
<span class="sd">          der zelle</span>
<span class="sd">    TODO: apply_electrostatic_potential fuer alle fkten mit 1,2,3 argumenten</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">__unitcellmatrixblocks</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">__unitcellnumbers</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">__orbitalspreads</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">__orbitalpositions</span><span class="o">=</span><span class="p">[]</span>
    <span class="c">#TODO: make a map/dictionary out of those two</span>
    <span class="n">__latticevecs</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">__nrbands</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">__fermi_energy</span><span class="o">=</span><span class="bp">None</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        There are several ways to initialize the Wannier90 Hamiltonian:</span>
<span class="sd">        1) Hamiltonian.from_file(wannier90filename,poscarfilename,wannier90woutfilename)</span>
<span class="sd">        2) Hamiltonian.from_raw_data(unitcellmatrixblocks,unitcellnumbers,latticevecs,orbitalspreads,orbitalpositions)</span>
<span class="sd">        3) Hamiltonian.from_nth_nn_list(nnfile,customhopping):</span>
<span class="sd">        </span>
<span class="sd">        See the documentation of those methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">mpi4py</span> <span class="kn">import</span> <span class="n">MPI</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpi_comm</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_comm</span><span class="o">.</span><span class="n">Get_size</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpi_comm</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">=</span> <span class="mi">0</span>
                
        <span class="c">#TODO: wannier90filename should be the id of the wannier90 calculation, and specific</span>
        <span class="c">#filenames derived from that (&#39;bla&#39; -&gt; bla.win, bla.wout, bla_hr.dat etc.). Then,</span>
        <span class="c">#kick out all filename method arguments</span>
        
<div class="viewcode-block" id="Hamiltonian.fermi_energy"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.fermi_energy">[docs]</a>    <span class="k">def</span> <span class="nf">fermi_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the system&#39;s Fermi energy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fermi_energy</span>
        </div>
<div class="viewcode-block" id="Hamiltonian.latticevectors"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.latticevectors">[docs]</a>    <span class="k">def</span> <span class="nf">latticevectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the system&#39;s lattice vectors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__latticevecs</span><span class="o">.</span><span class="n">latticevecs</span><span class="p">())</span> <span class="c">#copy</span>
    </div>
<div class="viewcode-block" id="Hamiltonian.reciprocal_latticevectors"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.reciprocal_latticevectors">[docs]</a>    <span class="k">def</span> <span class="nf">reciprocal_latticevectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the system&#39;s reciprocal lattice vectors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__latticevecs</span><span class="o">.</span><span class="n">reciprocal_latticevecs</span><span class="p">())</span> <span class="c">#copy</span>
    </div>
<div class="viewcode-block" id="Hamiltonian.orbitalspreads"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.orbitalspreads">[docs]</a>    <span class="k">def</span> <span class="nf">orbitalspreads</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the wannier90 orbital spreads.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__orbitalspreads</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Hamiltonian.orbitalpositions"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.orbitalpositions">[docs]</a>    <span class="k">def</span> <span class="nf">orbitalpositions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the wannier90 orbital positions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__orbitalpositions</span><span class="p">)</span> 
        </div>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Hamiltonian.from_file"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.from_file">[docs]</a>    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span><span class="n">wannier90filename</span><span class="p">,</span><span class="n">poscarfilename</span><span class="p">,</span><span class="n">wannier90woutfilename</span><span class="p">,</span><span class="n">outcarfilename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A constructor to create an object based on data from files.</span>
<span class="sd">        wannier90filename: Path to the wannier90_hr.dat file</span>
<span class="sd">        poscarfilename: Path to the VASP POSCAR file</span>
<span class="sd">        wannier90woutfilename: Path to the wannier90.wout file</span>
<span class="sd">        outcarfilename: Path to the VASP OUTCAR file</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="bp">self</span> <span class="o">=</span> <span class="n">cls</span><span class="p">()</span>
        
        <span class="n">poscardata</span> <span class="o">=</span> <span class="n">poscar</span><span class="o">.</span><span class="n">PoscarData</span><span class="p">(</span><span class="n">poscarfilename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__latticevecs</span><span class="o">=</span><span class="n">poscardata</span><span class="o">.</span><span class="n">lattice_vectors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__nrbands</span><span class="p">,</span><span class="n">wanndata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__read_wannier90_hr_file</span><span class="p">(</span><span class="n">wannier90filename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__unitcellmatrixblocks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__unitcellnumbers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__process_wannier90_hr_data</span><span class="p">(</span><span class="n">wanndata</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__orbitalspreads</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">__orbitalpositions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__orbital_spreads_and_positions</span><span class="p">(</span><span class="n">wannier90woutfilename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__fermi_energy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_fermi_energy_from_outcar</span><span class="p">(</span><span class="n">outcarfilename</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span>
    </div>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Hamiltonian.from_raw_data"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.from_raw_data">[docs]</a>    <span class="k">def</span> <span class="nf">from_raw_data</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span><span class="n">unitcellmatrixblocks</span><span class="p">,</span><span class="n">unitcellnumbers</span><span class="p">,</span><span class="n">latticevecs</span><span class="p">,</span><span class="n">orbitalspreads</span><span class="p">,</span><span class="n">orbitalpositions</span><span class="p">,</span><span class="n">fermi_energy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A constructor used to create a custom Hamiltonian.</span>
<span class="sd">        unitcellmatrixblocks: Hopping elements, arranged by unit cells.</span>
<span class="sd">        unitcellnumbers: coordinates of the unit cells &quot;hopped&quot; to.</span>
<span class="sd">        latticevecs: lattice vectors.</span>
<span class="sd">        orbitalspreads: spreads of the orbitals</span>
<span class="sd">        orbitalpositions: positions of the orbitals</span>
<span class="sd">        &quot;&quot;&quot;</span>              
        <span class="bp">self</span> <span class="o">=</span> <span class="n">cls</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">__unitcellnumbers</span> <span class="o">=</span> <span class="n">unitcellnumbers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__unitcellmatrixblocks</span> <span class="o">=</span> <span class="n">unitcellmatrixblocks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__latticevecs</span> <span class="o">=</span> <span class="n">poscar</span><span class="o">.</span><span class="n">LatticeVectors</span><span class="p">(</span><span class="n">latticevecs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__nrbands</span> <span class="o">=</span> <span class="n">unitcellmatrixblocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__orbitalspreads</span><span class="o">=</span><span class="n">orbitalspreads</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__orbitalpositions</span><span class="o">=</span><span class="n">orbitalpositions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__fermi_energy</span><span class="o">=</span><span class="n">fermi_energy</span>
        
        <span class="k">return</span> <span class="bp">self</span>
        </div>
    <span class="nd">@classmethod</span>        
<div class="viewcode-block" id="Hamiltonian.from_nth_nn_list"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.from_nth_nn_list">[docs]</a>    <span class="k">def</span> <span class="nf">from_nth_nn_list</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span><span class="n">nnfile</span><span class="p">,</span><span class="n">customhopping</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A constructor to create a nth-nearest-neighbour Hamiltonian.</span>
<span class="sd">        </span>
<span class="sd">        nnfile: File containing the system information (see example data)</span>
<span class="sd">        customhopping: Dictionary, containing hopping parameters overriding those in nnfile.</span>
<span class="sd">                       Example: {0:ONSITE,1:1STNN,2:2NDNN}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="n">cls</span><span class="p">()</span>
        
        <span class="n">latticevecs</span><span class="p">,</span><span class="n">nndata</span><span class="p">,</span><span class="n">orbitalspreads</span><span class="p">,</span><span class="n">orbitalpositions</span><span class="p">,</span><span class="n">defaulthopping</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__read_nth_nn_file</span><span class="p">(</span><span class="n">nnfile</span><span class="p">)</span>    
        
        <span class="k">if</span> <span class="n">customhopping</span><span class="o">==</span><span class="bp">None</span><span class="p">:</span>
            <span class="n">hopping</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">defaulthopping</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hopping</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">defaulthopping</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span><span class="nb">max</span><span class="p">(</span><span class="n">customhopping</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">defaulthopping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">hopping</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">v</span>
        
        <span class="k">if</span> <span class="n">customhopping</span><span class="o">!=</span><span class="bp">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">val</span> <span class="ow">in</span> <span class="n">customhopping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">hopping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">val</span>
            
        <span class="n">nrbands</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">orbitalspreads</span><span class="p">)</span>
        
        <span class="n">unitcellmatrixblocks</span><span class="p">,</span><span class="n">unitcellnumbers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__process_nth_nn_data</span><span class="p">(</span><span class="n">nndata</span><span class="p">,</span><span class="n">hopping</span><span class="p">,</span><span class="n">nrbands</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">__unitcellnumbers</span> <span class="o">=</span> <span class="n">unitcellnumbers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__unitcellmatrixblocks</span> <span class="o">=</span> <span class="n">unitcellmatrixblocks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__latticevecs</span> <span class="o">=</span> <span class="n">poscar</span><span class="o">.</span><span class="n">LatticeVectors</span><span class="p">(</span><span class="n">latticevecs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__nrbands</span> <span class="o">=</span> <span class="n">nrbands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__orbitalspreads</span><span class="o">=</span><span class="n">orbitalspreads</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__orbitalpositions</span><span class="o">=</span><span class="n">orbitalpositions</span>
        
        <span class="k">return</span> <span class="bp">self</span>
    </div>
    <span class="k">def</span> <span class="nf">__get_fermi_energy_from_outcar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">outcarfilename</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">outcarfilename</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        
        <span class="k">for</span> <span class="n">nr</span><span class="p">,</span><span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;E-fermi :&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ret</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>   
                
        <span class="n">fermi_energy</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="n">nr</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">2</span><span class="p">])</span>
        
        <span class="k">return</span> <span class="n">fermi_energy</span>
        
    <span class="k">def</span> <span class="nf">__read_nth_nn_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nnfile</span><span class="p">):</span>
        <span class="n">latticevecsstr</span><span class="p">,</span><span class="n">orbdatastr</span><span class="p">,</span><span class="n">defaulthoppingstr</span><span class="p">,</span><span class="n">nndatastr</span><span class="o">=</span><span class="n">general</span><span class="o">.</span><span class="n">split_by_empty_lines</span><span class="p">(</span><span class="n">general</span><span class="o">.</span><span class="n">read_file_as_table</span><span class="p">(</span><span class="n">nnfile</span><span class="p">),</span><span class="bp">True</span><span class="p">)</span>
        
        <span class="n">latticevecs</span><span class="o">=</span><span class="p">[[</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">line</span><span class="p">]</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">latticevecsstr</span><span class="p">]</span>
        <span class="n">nndata</span><span class="o">=</span><span class="p">[[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">line</span><span class="p">]</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">nndatastr</span><span class="p">]</span>
        <span class="n">orbitalspreads</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">orbdatastr</span><span class="p">]</span>
        <span class="n">orbitalpositions</span><span class="o">=</span><span class="p">[[</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">orbdatastr</span><span class="p">]</span>
        
        <span class="n">defaulthoppingindices</span><span class="o">=</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">defaulthoppingstr</span><span class="p">]</span>
        <span class="n">defaulthoppingvals</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">defaulthoppingstr</span><span class="p">]</span>
        <span class="n">defaulthopping</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">defaulthoppingindices</span><span class="p">,</span><span class="n">defaulthoppingvals</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">latticevecs</span><span class="p">,</span><span class="n">nndata</span><span class="p">,</span><span class="n">orbitalspreads</span><span class="p">,</span><span class="n">orbitalpositions</span><span class="p">,</span><span class="n">defaulthopping</span>
        
    <span class="k">def</span> <span class="nf">__process_nth_nn_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nndata</span><span class="p">,</span><span class="n">hopping</span><span class="p">,</span><span class="n">nrbands</span><span class="p">):</span>
        <span class="n">prevcell</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">unitcells</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">nndata</span><span class="p">:</span>
            <span class="n">currentcell</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">currentcell</span> <span class="o">!=</span> <span class="n">prevcell</span><span class="p">:</span>
                <span class="n">unitcells</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="n">unitcells</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="n">prevcell</span> <span class="o">=</span> <span class="n">currentcell</span>
        <span class="n">unitcellnumbers</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">unitcell</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]]</span> <span class="k">for</span> <span class="n">unitcell</span> <span class="ow">in</span> <span class="n">unitcells</span><span class="p">]</span>

        <span class="n">unitcellmatrixblocks</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">unitcell</span> <span class="ow">in</span> <span class="n">unitcells</span><span class="p">:</span>
            <span class="n">block</span><span class="o">=</span><span class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">((</span><span class="n">nrbands</span><span class="p">,</span><span class="n">nrbands</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">unitcell</span><span class="p">:</span>
                <span class="n">block</span><span class="p">[</span><span class="n">element</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">element</span><span class="p">[</span><span class="mi">4</span><span class="p">]]</span><span class="o">=</span><span class="n">hopping</span><span class="p">[</span><span class="n">element</span><span class="p">[</span><span class="mi">5</span><span class="p">]]</span>
            <span class="n">unitcellmatrixblocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">tocsr</span><span class="p">())</span>
                
        <span class="k">return</span> <span class="n">unitcellmatrixblocks</span><span class="p">,</span><span class="n">unitcellnumbers</span>
        
    <span class="k">def</span> <span class="nf">__process_wannier90_hr_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wanndata</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads hopping matrix elements from wanndata into object. wanndata is a list</span>
<span class="sd">        of lines, each line being a list in the following format:</span>
<span class="sd">        veca vecb vecc thisorb otherorb re im</span>
<span class="sd">        </span>
<span class="sd">        veca,vecb,vecc: Unit cell coordinates of other cell</span>
<span class="sd">        thisorb: Nr of orbital in main cell</span>
<span class="sd">        otherorb: Nr of orbital in other cell</span>
<span class="sd">        re, im: Hopping matrix element</span>
<span class="sd">        </span>
<span class="sd">        Hopping matrix elements have to be sorted by unit cell coordinates (veca,vecb,vecc).</span>
<span class="sd">        Then, they have to be sorted by thisorb and otherorb, with thisorb running faster</span>
<span class="sd">        than otherorb.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prevcell</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">unitcells</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">wanndata</span><span class="p">:</span>
            <span class="n">currentcell</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">currentcell</span> <span class="o">!=</span> <span class="n">prevcell</span><span class="p">:</span>
                <span class="n">unitcells</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="n">unitcells</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="n">prevcell</span> <span class="o">=</span> <span class="n">currentcell</span>
        
        <span class="n">unitcellnumbers</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">unitcell</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]]</span> <span class="k">for</span> <span class="n">unitcell</span> <span class="ow">in</span> <span class="n">unitcells</span><span class="p">]</span>
        <span class="n">unitcellmatrixblocks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">unitcell</span> <span class="ow">in</span> <span class="n">unitcells</span><span class="p">:</span>
            <span class="n">elementlist</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">complex</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">5</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">6</span><span class="p">]))</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">unitcell</span><span class="p">])</span>
            <span class="n">unitcellmatrixblocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">elementlist</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">__nrbands</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nrbands</span><span class="p">))))</span> <span class="c">#Transpose because first index in wannier90_hr.dat file runs faster than second</span>
        
        <span class="k">return</span> <span class="n">unitcellmatrixblocks</span><span class="p">,</span> <span class="n">unitcellnumbers</span>

    <span class="k">def</span> <span class="nf">__read_wannier90_hr_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="p">):</span>
        <span class="n">data</span><span class="o">=</span><span class="n">general</span><span class="o">.</span><span class="n">read_file_as_table</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        
        <span class="n">nrbands</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">linestart</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mi">15</span><span class="p">))</span><span class="o">+</span><span class="mi">3</span>
        <span class="n">wanndata</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">linestart</span><span class="p">:]</span>
        
        <span class="k">return</span> <span class="n">nrbands</span><span class="p">,</span><span class="n">wanndata</span>
        <span class="c">#scipy.linalg.blas.fblas.zaxpy</span>
        
    <span class="k">def</span> <span class="nf">__bloch_phases</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">k</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the bloch factor e^ikr for each unit cell in</span>
<span class="sd">        self.__unitcellnumbers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#TODO: if k is direct: lattice vectors are probably not necessary. How could that work?</span>
        <span class="n">latticevecs_transposed</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__latticevecs</span><span class="o">.</span><span class="n">latticevecs</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cmath</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="nb">complex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> \
        <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">latticevecs_transposed</span><span class="p">,</span><span class="n">cellnumber</span><span class="p">)))</span> <span class="k">for</span> <span class="n">cellnumber</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__unitcellnumbers</span><span class="p">])</span>
        
    <span class="k">def</span> <span class="nf">__unitcellcoordinates_to_nrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">usedhoppingcells</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a list of unit cell coordinates, the function</span>
<span class="sd">        converts them to integer indices i for __unitcellmatrixblocks[i] and</span>
<span class="sd">        __unitcellnumbers[i].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">indices</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">usedhoppingcells</span><span class="p">:</span>
            <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__unitcellnumbers</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
            <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">indices</span>
    
    <span class="k">def</span> <span class="nf">__sorting_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="n">key</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sorts a list by the given column sortcolumn and returns the order. </span>
<span class="sd">        If key==None (default), all columns are sorted, with the last column running fastest.</span>
<span class="sd">        E.g. for sorting by the second column, set key=lambda w: w[1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span><span class="o">==</span><span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">key</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))]</span>
    
    
    <span class="k">def</span> <span class="nf">__apply_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="n">order</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Applies an order to a list.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">order</span><span class="p">]</span>
    
<div class="viewcode-block" id="Hamiltonian.write_matrix_elements"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.write_matrix_elements">[docs]</a>    <span class="k">def</span> <span class="nf">write_matrix_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">outputfile</span><span class="p">,</span><span class="n">usedhoppingcells</span><span class="o">=</span><span class="s">&#39;all&#39;</span><span class="p">,</span><span class="n">usedorbitals</span><span class="o">=</span><span class="s">&#39;all&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the wannier90 matrix elements to a file (*.wetb) readable by Florian&#39;s code.</span>
<span class="sd">        Information contained in the file:</span>
<span class="sd">        - lattice vectors</span>
<span class="sd">        - orbital positions</span>
<span class="sd">        - orbital spreads</span>
<span class="sd">        - matrix elements of the chosen unit cells and orbitals</span>
<span class="sd">        </span>
<span class="sd">        Description of the file format:</span>
<span class="sd">        The file contains three sections, divided by an arbitrary number of blank lines (one at least,</span>
<span class="sd">        obviously). Lines starting with # are comments and are ignored. Anything in a line after the</span>
<span class="sd">        data is also ignored (i.e. you can write anything in the same line after the data, with or</span>
<span class="sd">        without #).</span>
<span class="sd">        First block: lattice vectors in rows</span>
<span class="sd">        Second block: orbital spread (first column) and position (other columns) of every orbital</span>
<span class="sd">        Third block: Matrix elements.</span>
<span class="sd">            Column 1-3: Unit cell number</span>
<span class="sd">            Column 4: Orbital number in main unit cell</span>
<span class="sd">            Column 5: Orbital number in other unit cell (the one the electron &quot;hops&quot; to)</span>
<span class="sd">            Column 6&amp;7: Real &amp; imaginary part of the matrix element</span>
<span class="sd">        </span>
<span class="sd">        outputfile: Name of the output file (*.wetb - Wannier90-Environmental-dependent-Tight-Binding)</span>
<span class="sd">        usedhoppingcells: If you don&#39;t want to use all hopping parameters,</span>
<span class="sd">        you can set them here (get the list of available cells with unitcellnumbers() and</span>
<span class="sd">        strip the list from unwanted cells).</span>
<span class="sd">        usedorbitals: a list of used orbitals to use. Default is &#39;all&#39;. Note: this only makes</span>
<span class="sd">        sense if the selected orbitals don&#39;t interact with other orbitals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">output</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">outputfile</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">usedhoppingcells</span> <span class="o">==</span> <span class="s">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">usedunitcellnrs</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__unitcellnumbers</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">usedunitcellnrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__unitcellcoordinates_to_nrs</span><span class="p">(</span><span class="n">usedhoppingcells</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">usedorbitals</span><span class="o">==</span><span class="s">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">orbitalnrs</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nrbands</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">orbitalnrs</span><span class="o">=</span><span class="n">usedorbitals</span>
            
        <span class="n">order_usedunitcellnumbers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__apply_order</span><span class="p">(</span><span class="n">usedunitcellnrs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sorting_order</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">__unitcellnumbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">usedunitcellnrs</span><span class="p">]))</span>
            
        <span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;#WETB File</span><span class="se">\n\n</span><span class="s">&#39;</span><span class="p">)</span>
        <span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;#Lattice vectors:</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
        <span class="n">latticevecs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__latticevecs</span><span class="o">.</span><span class="n">latticevecs</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">vec</span> <span class="ow">in</span> <span class="n">latticevecs</span><span class="p">:</span>
            <span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;{:12.6f} {:12.6f} {:12.6f}</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">vec</span><span class="p">))</span>
        <span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n\n</span><span class="s">&#39;</span><span class="p">)</span>
        <span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;#Spreads and positions of the orbitals:</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
        <span class="n">spreads</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__orbitalspreads</span>
        <span class="n">positions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__orbitalpositions</span>
        <span class="k">for</span> <span class="n">spread</span><span class="p">,</span><span class="n">position</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">spreads</span><span class="p">,</span><span class="n">positions</span><span class="p">):</span>
            <span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;{:12.6f} &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spread</span><span class="p">))</span>
            <span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;{:12.6f} {:12.6f} {:12.6f}</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">position</span><span class="p">))</span>
        <span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n\n</span><span class="s">&#39;</span><span class="p">)</span>
        
        <span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;#Unit cell number, main orbital, other orbital, hopping element:</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">order_usedunitcellnumbers</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__unitcellmatrixblocks</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">numpy</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">orbitalnrs</span><span class="p">,</span><span class="n">orbitalnrs</span><span class="p">)]):</span>
                <span class="c">#j: ndenumerate assigns the hop-from and hop-to number to each hopping matrix element</span>
                
                <span class="c">#http://docs.python.org/library/string.html#format-specification-mini-language</span>
                <span class="n">cellnrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__unitcellnumbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;{:5d} {:5d} {:5d} &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">cellnrs</span><span class="p">))</span>
                <span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;{:5d} {:5d} &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">j</span><span class="p">))</span>
                <span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;{:12.6f} {:12.6f}</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">real</span><span class="p">,</span><span class="n">val</span><span class="o">.</span><span class="n">imag</span><span class="p">))</span>
                            
                
        
        <span class="n">output</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>    
    </div>
<div class="viewcode-block" id="Hamiltonian.maincell_eigenvalues"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.maincell_eigenvalues">[docs]</a>    <span class="k">def</span> <span class="nf">maincell_eigenvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">solver</span><span class="o">=</span><span class="s">&#39;dense&#39;</span><span class="p">,</span><span class="n">return_evecs</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the eigenvalues of the main cell (no hopping to adjacent unit cells).</span>
<span class="sd">        </span>
<span class="sd">        solver: eigenvalue solver. There are:</span>
<span class="sd">            &#39;dense&#39;: Assuming a dense matrix; returns all eigenvalues. Uses</span>
<span class="sd">            scipy.linalg.eig. E.g.</span>
<span class="sd">            &gt;&gt;&gt; evals=ham.maincell_eigenvalues()</span>
<span class="sd">            &#39;scipy_arpack&#39;: find a given number of eigenvalues and eigenvectors of</span>
<span class="sd">            a BIG, SPARSE matrix (including shift-invert). It can never give you</span>
<span class="sd">            all eigenvalues. Uses ARPACK through scipy.sparse.linalg.eigsh.</span>
<span class="sd">            You have to supply additional parameters for eigsh using **kwargs, e.g.</span>
<span class="sd">            &gt;&gt;&gt; ham.maincell_eigenvalues(&#39;arpack&#39;,k=10,sigma=0.0,ncv=100)</span>
<span class="sd">            See http://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.eigsh.html</span>
<span class="sd">            for the available parameters. You will probably need k,sigma, and maybe nvc, which.</span>
<span class="sd">            Consider using which=&#39;SM&#39; if E_F=0.</span>
<span class="sd">        return_evecs: Also return eigenvectors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c">#XXX: Make solver an abstract class</span>
        <span class="n">blochmatrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__unitcellmatrixblocks</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__unitcellcoordinates_to_nrs</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])[</span><span class="mi">0</span><span class="p">]]</span>
        
        <span class="n">evals</span><span class="o">=</span><span class="bp">None</span>
        <span class="n">evecs</span><span class="o">=</span><span class="bp">None</span>
        
        <span class="k">if</span> <span class="n">return_evecs</span> <span class="ow">and</span> <span class="n">solver</span><span class="o">==</span><span class="s">&#39;scipy_arpack&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        
        <span class="k">if</span> <span class="n">solver</span><span class="o">==</span><span class="s">&#39;scipy_arpack&#39;</span><span class="p">:</span>
            <span class="c">#http://docs.scipy.org/doc/scipy/reference/tutorial/arpack.html</span>
            <span class="c">#XXX: inverter superlu works best with csc matrices. Can one do something about that?</span>
            <span class="c">#XXX: k=10 --&gt; vectors have length 10? WRONG!!!</span>
            <span class="n">evals</span><span class="p">,</span><span class="n">evecs</span><span class="o">=</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigsh</span><span class="p">(</span><span class="n">blochmatrix</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c">#return numpy.sort(evals.real)</span>
        <span class="k">elif</span> <span class="n">solver</span><span class="o">==</span><span class="s">&#39;dense&#39;</span><span class="p">:</span>
            <span class="n">evals</span><span class="p">,</span><span class="n">evecs</span><span class="o">=</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">blochmatrix</span><span class="o">.</span><span class="n">todense</span><span class="p">())</span>
            <span class="c">#return numpy.sort(evals.real)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Supplied solver not found&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">return_evecs</span><span class="p">:</span>
            <span class="n">evals_ordering</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__sorting_order</span><span class="p">(</span><span class="n">evals</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__apply_order</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span><span class="n">evals_ordering</span><span class="p">)),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__apply_order</span><span class="p">(</span><span class="n">evecs</span><span class="p">,</span><span class="n">evals_ordering</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">evals</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
        </div>
<div class="viewcode-block" id="Hamiltonian.maincell_hamiltonian_matrix"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.maincell_hamiltonian_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">maincell_hamiltonian_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Hamiltonian matrix for the main cell, without hopping</span>
<span class="sd">        parameters to other cells. This is the matrix whose eigenvalues</span>
<span class="sd">        you can calculate using maincell_eigenvalues().      </span>
<span class="sd">        &quot;&quot;&quot;</span> 
                   
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__unitcellmatrixblocks</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__unitcellcoordinates_to_nrs</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])[</span><span class="mi">0</span><span class="p">]]</span>
    </div>
<div class="viewcode-block" id="Hamiltonian.bloch_eigenvalues"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.bloch_eigenvalues">[docs]</a>    <span class="k">def</span> <span class="nf">bloch_eigenvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">basis</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">,</span><span class="n">usedhoppingcells</span><span class="o">=</span><span class="s">&#39;all&#39;</span><span class="p">,</span><span class="n">return_evecs</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the eigenvalues of the eigenvalue problem with</span>
<span class="sd">        Bloch boundary conditions for a given vector k.</span>
<span class="sd">        </span>
<span class="sd">        The function uses a dense matrix eigenvalue solver because it returns all</span>
<span class="sd">        eigenvalues, so don&#39;t let the matrices get too big.</span>
<span class="sd">        </span>
<span class="sd">        usedhoppingcells: If you don&#39;t want to use all hopping parameters,</span>
<span class="sd">        you can set them here (get the list of available cells with unitcellnumbers() and</span>
<span class="sd">        strip the list from unwanted cells).</span>
<span class="sd">        basis: &#39;c&#39; or &#39;d&#39;. Determines if the kpoints are given in cartesian</span>
<span class="sd">        reciprocal coordinates or direct reciprocal coordinates.</span>
<span class="sd">        return_evecs: If True, evecs are also returned as the second return value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">usedhoppingcells</span> <span class="o">==</span> <span class="s">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">usedunitcellnrs</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__unitcellnumbers</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">usedunitcellnrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__unitcellcoordinates_to_nrs</span><span class="p">(</span><span class="n">usedhoppingcells</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">basis</span><span class="o">==</span><span class="s">&#39;d&#39;</span><span class="p">:</span>
            <span class="n">k</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__latticevecs</span><span class="o">.</span><span class="n">direct_to_cartesian_reciprocal</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            
        <span class="n">orbitalnrs</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nrbands</span><span class="p">)</span>
        
        <span class="n">bloch_phases</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__bloch_phases</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="c">#I think this needs lil_matrix, coo_matrix didn&#39;t work.</span>
        <span class="n">blochmatrix</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">orbitalnrs</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">orbitalnrs</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">usedunitcellnrs</span><span class="p">:</span>
            <span class="n">blochmatrix</span> <span class="o">+=</span> <span class="n">bloch_phases</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__unitcellmatrixblocks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">evals</span><span class="p">,</span><span class="n">evecs</span><span class="o">=</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">blochmatrix</span><span class="o">.</span><span class="n">todense</span><span class="p">())</span>
        
        <span class="k">if</span> <span class="n">return_evecs</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
            <span class="n">evals_ordering</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__sorting_order</span><span class="p">(</span><span class="n">evals</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__apply_order</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span><span class="n">evals_ordering</span><span class="p">)),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__apply_order</span><span class="p">(</span><span class="n">evecs</span><span class="p">,</span><span class="n">evals_ordering</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">evals</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
            </div>
<div class="viewcode-block" id="Hamiltonian.create_orbital_vector_list"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.create_orbital_vector_list">[docs]</a>    <span class="k">def</span> <span class="nf">create_orbital_vector_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">vector</span><span class="p">,</span><span class="n">include_third_dimension</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">include_spread</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a list of orbital positions with given eigenvector amplitudes. Only the real part from</span>
<span class="sd">        the eigenvector is kept.</span>
<span class="sd">        </span>
<span class="sd">        vector: Vector to connect to the orbital positions.</span>
<span class="sd">        include_third_dimension: Include the z position of the points. Default is False.</span>
<span class="sd">        include_spread: Include the spread of the orbital. Default is False.</span>
<span class="sd">        </span>
<span class="sd">        Return: A matrix containing the following columns:</span>
<span class="sd">                x   y   (z)   (spread)    value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">include_third_dimension</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
            <span class="n">pos</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__orbitalpositions</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__orbitalpositions</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
            
        <span class="k">if</span> <span class="n">include_spread</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
            <span class="n">pos</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">__orbitalspreads</span><span class="p">])),</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="n">pos</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="n">vector</span><span class="p">])),</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">pos</span>
        </div>
<div class="viewcode-block" id="Hamiltonian.plot_vector"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.plot_vector">[docs]</a>    <span class="k">def</span> <span class="nf">plot_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">vector</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot a vector with geometry by putting circles on the positions of the orbitals.</span>
<span class="sd">        The size of the circles corresponds to the absolute square, the color to the sign.</span>
<span class="sd">        </span>
<span class="sd">        vector: vector to plot</span>
<span class="sd">        scale: scale factor for the circles.</span>
<span class="sd">        figsize: w,h tuple in inches</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">pyplot</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
        <span class="n">pyplot</span><span class="o">.</span><span class="n">axes</span><span class="p">()</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s">&#39;equal&#39;</span><span class="p">,</span><span class="s">&#39;datalim&#39;</span><span class="p">)</span>
        <span class="n">colors</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;r&#39;</span> <span class="k">if</span> <span class="n">x</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="s">&#39;b&#39;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">vector</span><span class="p">]</span>
        <span class="n">pos</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__orbitalpositions</span><span class="p">)</span>
        <span class="n">pyplot</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">pos</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">pos</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">scale</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span><span class="n">edgecolors</span><span class="o">=</span><span class="s">&#39;none&#39;</span><span class="p">)</span>
        </div>
<div class="viewcode-block" id="Hamiltonian.plot_orbital_positions"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.plot_orbital_positions">[docs]</a>    <span class="k">def</span> <span class="nf">plot_orbital_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the positions of the orbitals in the unit cell.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_vector</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__orbitalpositions</span><span class="p">)))</span>
    </div>
<div class="viewcode-block" id="Hamiltonian.bandstructure_data"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.bandstructure_data">[docs]</a>    <span class="k">def</span> <span class="nf">bandstructure_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">kpoints</span><span class="p">,</span><span class="n">basis</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">,</span><span class="n">usedhoppingcells</span><span class="o">=</span><span class="s">&#39;all&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the bandstructure for a given kpoint list.</span>
<span class="sd">        For direct plotting, use plot_bandstructure(kpoints,filename).</span>
<span class="sd">                </span>
<span class="sd">        If kpoints is a string, this string will be interpreted as the</span>
<span class="sd">        name of the crystal structure (see standard_paths), and the crystal</span>
<span class="sd">        structure&#39;s default kpoint path will be used.</span>
<span class="sd">        </span>
<span class="sd">        usedhoppingcells: If you don&#39;t want to use all hopping parameters,</span>
<span class="sd">        you can set them here (get the list of available cells with unitcellnumbers() and</span>
<span class="sd">        strip the list from unwanted cells).        </span>
<span class="sd">        basis: &#39;c&#39; or &#39;d&#39;. Determines if the kpoints are given in cartesian</span>
<span class="sd">        reciprocal coordinates or direct reciprocal coordinates.</span>

<span class="sd">        Return:</span>
<span class="sd">        A list of eigenvalues for each kpoint is returned. To sort </span>
<span class="sd">        by band, use data.transpose().</span>

<span class="sd">        If MPI is used, ONLY THE ROOT PROCESS returns the data, the others</span>
<span class="sd">        return None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kpoints</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="n">kpoints</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">standard_paths</span><span class="p">(</span><span class="n">kpoints</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">basis</span><span class="o">=</span><span class="s">&#39;d&#39;</span>


        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_comm</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">path_parts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">kpoints</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mpi_size</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">path_parts</span> <span class="o">=</span> <span class="bp">None</span>

            <span class="n">path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mpi_comm</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">path_parts</span><span class="p">,</span><span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">path</span><span class="o">=</span><span class="n">kpoints</span>

        <span class="n">data</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">bloch_eigenvalues</span><span class="p">(</span><span class="n">kpoint</span><span class="p">,</span><span class="n">basis</span><span class="p">,</span><span class="n">usedhoppingcells</span><span class="p">)</span>
                          <span class="k">for</span> <span class="n">kpoint</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_comm</span><span class="p">:</span>
            <span class="n">allbsdata</span><span class="o">=</span><span class="bp">None</span>
            <span class="n">allbsdata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mpi_comm</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">allbsdata</span><span class="p">)</span>
<span class="c">#        allbsdata=numpy.empty((len(kpoints),self.__nrbands))</span>
<span class="c">#        comm.Allgather([data,MPI.DOUBLE],[allbsdata,MPI.DOUBLE])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span>
    </div>
<div class="viewcode-block" id="Hamiltonian.point_path"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.point_path">[docs]</a>    <span class="k">def</span> <span class="nf">point_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">corner_points</span><span class="p">,</span><span class="n">nrpointspersegment</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a path connecting the corner_points with nrpointspersegment points per segment</span>
<span class="sd">        (excluding the next point), resulting in sum(nrpointspersegment)+1 points.</span>
<span class="sd">        The points in corner_points can have any dimension.</span>
<span class="sd">        nrpointspersegment is a list with one element less than corner_points.</span>
<span class="sd">        If nrpointspersegment is an integer, it is assumed to apply to each segment.</span>
<span class="sd">        </span>
<span class="sd">        Example: </span>
<span class="sd">        my_hamiltonian.point_path([[0,0],[1,1],[2,2]],[2,2])</span>
<span class="sd">        gives        </span>
<span class="sd">        [[0.0, 0.0], [0.5, 0.5], [1.0, 1.0], [1.5, 1.5], [2, 2]]</span>
<span class="sd">        (note: those are 5 points, which is sum([2,2])+1)</span>
<span class="sd">        </span>
<span class="sd">        or equivalently:</span>
<span class="sd">        my_hamiltonian.point_path([[0,0],[1,1],[2,2]],2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="sd">&quot;&quot;&quot;TODO: maybe put this function somewhere else?&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">nrpointspersegment</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">int</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">corner_points</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nrpointspersegment</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;corner_points has to be one element larger than nrpointspersegment, unless nrpointspersegment is integer.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">nrpointspersegment</span><span class="p">)</span><span class="o">==</span><span class="nb">int</span><span class="p">:</span>
            <span class="n">nrpointspersegment</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">corner_points</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">[</span><span class="n">nrpointspersegment</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">corner_points</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">!=</span><span class="nb">list</span><span class="p">:</span>
            <span class="n">corner_points</span><span class="o">=</span><span class="p">[[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">corner_points</span><span class="p">]</span>

        <span class="n">points</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nrpointspersegment</span><span class="p">)):</span>
            <span class="n">newpoints</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__path_between_two_vectors</span><span class="p">(</span><span class="n">corner_points</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">corner_points</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">nrpointspersegment</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">points</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">newpoints</span><span class="p">)</span>
            
        <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corner_points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            
        <span class="k">return</span> <span class="n">points</span>
    </div>
    <span class="k">def</span> <span class="nf">__path_between_two_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">nrpoints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a path between v1 and v2 (lists of any dimension) with nrpoints elements.</span>
<span class="sd">        The last point, v2, is not in the path.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dimension</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">v1</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> \
                <span class="n">v2</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">nrpoints</span><span class="p">,</span><span class="n">endpoint</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimension</span><span class="p">)])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        
<div class="viewcode-block" id="Hamiltonian.plot_bandstructure"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.plot_bandstructure">[docs]</a>    <span class="k">def</span> <span class="nf">plot_bandstructure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">kpoints</span><span class="p">,</span><span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">basis</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">,</span><span class="n">usedhoppingcells</span><span class="o">=</span><span class="s">&#39;all&#39;</span><span class="p">,</span><span class="n">mark_reclattice_points</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">mark_fermi_energy</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the bandstructure at the points kpoints (given in </span>
<span class="sd">        cartesian reciprocal coordinates - use direct_to_cartesian_reciprocal(k)</span>
<span class="sd">        if you want to use direct coordinates) and save the plot</span>
<span class="sd">        to filename. The ending of filename determines the file format. If </span>
<span class="sd">        filename=None (default), the plot will not be saved (you can display</span>
<span class="sd">        it using pyplot.show() ).</span>
<span class="sd">        </span>
<span class="sd">        If kpoints is a string, this string will be interpreted as the</span>
<span class="sd">        name of the crystal structure (see standard_paths), and the crystal</span>
<span class="sd">        structure&#39;s default kpoint path will be used.</span>
<span class="sd">        </span>
<span class="sd">        usedhoppingcells: If you don&#39;t want to use all hopping parameters,</span>
<span class="sd">        you can set them here (get the list of available cells with unitcellnumbers() and</span>
<span class="sd">        strip the list from unwanted cells).  </span>
<span class="sd">        basis: &#39;c&#39; or &#39;d&#39;. Determines if the kpoints are given in cartesian</span>
<span class="sd">        reciprocal coordinates or direct reciprocal coordinates.</span>
<span class="sd">        mark_reclattice_points: You can mark important reciprocal lattice points, like</span>
<span class="sd">        \Gamma or K. This variable can be (i) True if you use a string for kpoints</span>
<span class="sd">        (ii) a list which contains the names of the points and the points:</span>
<span class="sd">        mark_reclattice_points=[names,points]. The points have to be in </span>
<span class="sd">        cartesian coordinates. Default is False.</span>
<span class="sd">        mark_fermi_energy: If you supply the Fermi energy here, a line will be</span>
<span class="sd">        drawn. If True, the Fermi energy will be taken from fermi_energy().</span>
<span class="sd">        Default is False.</span>
<span class="sd">        </span>
<span class="sd">        If MPI is used, ONLY THE ROOT PROCESS plots. This coincides with bandstructure_data,</span>
<span class="sd">        where also only the root process returns all the bandstructure data.</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">        lines: List of matplotlib.lines.Line2D objects that were drawn. You</span>
<span class="sd">        can change the style, color etc., like:</span>
<span class="sd">            for line in lines:</span>
<span class="sd">                line.set_color(&#39;red&#39;)</span>
<span class="sd">        fermi_energy_line: The fermi energy mark Line2D object.</span>
<span class="sd">        lattice_point_lines: The lattice point marks Line2D object.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bandstructure_data</span><span class="p">(</span><span class="n">kpoints</span><span class="p">,</span><span class="n">basis</span><span class="p">,</span><span class="n">usedhoppingcells</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            
            <span class="n">bplot</span><span class="o">=</span><span class="n">BandstructurePlot</span><span class="p">()</span>
        
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kpoints</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
                <span class="n">reclattice_points</span><span class="p">,</span><span class="n">reclattice_names</span><span class="p">,</span><span class="n">kpoints</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">standard_paths</span><span class="p">(</span><span class="n">kpoints</span><span class="p">)</span>
                <span class="n">basis</span><span class="o">=</span><span class="s">&#39;d&#39;</span>
            
            <span class="n">lattice_point_lines</span><span class="o">=</span><span class="bp">None</span>
            <span class="n">fermi_energy_line</span><span class="o">=</span><span class="bp">None</span>
            
            <span class="n">lines</span><span class="o">=</span><span class="n">bplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kpoints</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mark_fermi_energy</span><span class="p">,</span><span class="nb">bool</span><span class="p">):</span>
                <span class="n">fermi_energy_line</span><span class="o">=</span><span class="n">bplot</span><span class="o">.</span><span class="n">plot_fermi_energy</span><span class="p">(</span><span class="n">mark_fermi_energy</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">mark_fermi_energy</span><span class="p">:</span>
                <span class="n">fermi_energy_line</span><span class="o">=</span><span class="n">bplot</span><span class="o">.</span><span class="n">plot_fermi_energy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fermi_energy</span><span class="p">())</span>
            
            <span class="k">if</span> <span class="n">mark_reclattice_points</span> <span class="o">!=</span> <span class="bp">False</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mark_reclattice_points</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
                    <span class="n">lattice_point_lines</span><span class="o">=</span><span class="n">bplot</span><span class="o">.</span><span class="n">plot_lattice_point_vlines</span><span class="p">(</span><span class="n">reclattice_points</span><span class="p">,</span> <span class="n">reclattice_names</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="k">if</span> <span class="n">filename</span><span class="o">!=</span><span class="bp">None</span><span class="p">:</span>
                <span class="n">pyplot</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            
            <span class="k">return</span> <span class="n">lines</span><span class="p">,</span><span class="n">fermi_energy_line</span><span class="p">,</span><span class="n">lattice_point_lines</span>

        <span class="k">return</span>
        </div>
<div class="viewcode-block" id="Hamiltonian.drawunitcells"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.drawunitcells">[docs]</a>    <span class="k">def</span> <span class="nf">drawunitcells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">unitcellnumbers</span><span class="o">=</span><span class="s">&#39;all&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a plot of a list of unit cells.</span>
<span class="sd">        </span>
<span class="sd">        unitcellnumbers: Numbers of unit cells to plot.</span>
<span class="sd">        Default value is &#39;all&#39;, then unitcellnumbers() is used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">unitcellnumbers</span> <span class="o">==</span> <span class="s">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">unitcellnumbers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__unitcellnumbers</span>
        
        <span class="n">cellstructure</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">lv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__latticevecs</span><span class="o">.</span><span class="n">latticevecs</span><span class="p">()</span>
        <span class="n">unitcellform</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cellstructure</span><span class="p">,</span><span class="n">lv</span><span class="p">)[:,:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">cellcoords</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unitcellcoordinates</span><span class="p">(</span><span class="n">unitcellnumbers</span><span class="p">)[:,:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">maincell</span><span class="o">=</span><span class="n">unitcellnumbers</span><span class="o">.</span><span class="n">index</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">verticeslist</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">formpoint</span><span class="o">+</span><span class="n">cellcoordinate</span> <span class="k">for</span> <span class="n">formpoint</span> <span class="ow">in</span> <span class="n">unitcellform</span><span class="p">]</span> <span class="k">for</span> <span class="n">cellcoordinate</span> <span class="ow">in</span> <span class="n">cellcoords</span><span class="p">])</span>
        <span class="n">maincellvertices</span><span class="o">=</span><span class="n">verticeslist</span><span class="p">[</span><span class="n">maincell</span><span class="p">]</span>
        <span class="n">verticeslist</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">verticeslist</span><span class="p">,</span><span class="n">maincell</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>   
        
        <span class="c">#http://matplotlib.sourceforge.net/users/path_tutorial.html</span>
        
        <span class="n">codes</span> <span class="o">=</span> <span class="p">[</span><span class="n">Path</span><span class="o">.</span><span class="n">MOVETO</span><span class="p">,</span>
         <span class="n">Path</span><span class="o">.</span><span class="n">LINETO</span><span class="p">,</span>
         <span class="n">Path</span><span class="o">.</span><span class="n">LINETO</span><span class="p">,</span>
         <span class="n">Path</span><span class="o">.</span><span class="n">LINETO</span><span class="p">,</span>
         <span class="n">Path</span><span class="o">.</span><span class="n">CLOSEPOLY</span><span class="p">,</span>
         <span class="p">]</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">pyplot</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">verts</span> <span class="ow">in</span> <span class="n">verticeslist</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">codes</span><span class="p">)</span>
            <span class="n">patch</span> <span class="o">=</span> <span class="n">patches</span><span class="o">.</span><span class="n">PathPatch</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s">&#39;white&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span>
        

        <span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">maincellvertices</span><span class="p">,</span> <span class="n">codes</span><span class="p">)</span>
        <span class="n">patch</span> <span class="o">=</span> <span class="n">patches</span><span class="o">.</span><span class="n">PathPatch</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s">&#39;orange&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span>
        
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mi">40</span><span class="p">,</span><span class="mi">40</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">40</span><span class="p">,</span><span class="mi">40</span><span class="p">)</span>      
           
        </div>
<div class="viewcode-block" id="Hamiltonian.unitcellcoordinates"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.unitcellcoordinates">[docs]</a>    <span class="k">def</span> <span class="nf">unitcellcoordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">unitcellnumbers</span><span class="o">=</span><span class="s">&#39;all&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cartesian coordinates of the given unit cells.</span>
<span class="sd">        </span>
<span class="sd">        unitcellnumbers: a list of the unit cell numbers. </span>
<span class="sd">        Default value is &#39;all&#39;, then unitcellnumbers() is used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        How the formula works:</span>
<span class="sd">        </span>
<span class="sd">        The unitcellnumbers are the coordinates of the unit</span>
<span class="sd">        cells in the basis spanned by the lattice vectors. A transformation</span>
<span class="sd">        to cartesian coordinates is just a basis transformation. The columns of</span>
<span class="sd">        the transformation matrix are the lattice vectors in cartesian</span>
<span class="sd">        coordinates --&gt; we just have to transpose the list of lattice vectors.</span>
<span class="sd">        Instead of applying the transformation matrix to each vector, we apply</span>
<span class="sd">        it to all of them at the same time by writing the vectors in the columns</span>
<span class="sd">        of a matrix (=transposing the list of unit cell numbers).</span>
<span class="sd">        Since the transformed vectors are in the columns of the result matrix,</span>
<span class="sd">        we need to transpose that one again.</span>
<span class="sd">        </span>
<span class="sd">        The formula is now (&#39; = transpose):</span>
<span class="sd">        (latticevecs&#39; unitcellnumbers&#39;)&#39;</span>
<span class="sd">        </span>
<span class="sd">        But this is:</span>
<span class="sd">        (A&#39;B&#39;)&#39;=((BA)&#39;)&#39;=BA</span>
<span class="sd">        </span>
<span class="sd">        --&gt;</span>
<span class="sd">        unitcellnumbers latticevecs</span>
<span class="sd">        </span>
<span class="sd">        So that&#39;s the formula!</span>
<span class="sd">        </span>
<span class="sd">         </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">latticevecs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__latticevecs</span><span class="o">.</span><span class="n">latticevecs</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">unitcellnumbers</span> <span class="o">==</span> <span class="s">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">unitcellnumbers</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__unitcellnumbers</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">unitcellnumbers</span><span class="p">,</span><span class="n">latticevecs</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Hamiltonian.unitcells_within_zone"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.unitcells_within_zone">[docs]</a>    <span class="k">def</span> <span class="nf">unitcells_within_zone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">zone</span><span class="p">,</span><span class="n">basis</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">,</span><span class="n">norm_order</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of unit cells within a certain area. The function</span>
<span class="sd">        is comparing the same point in each cell (e.g. always the bottom left end).</span>
<span class="sd">        </span>
<span class="sd">        zone: can be a number or a tuple:</span>
<span class="sd">            number: radius to include cells within.</span>
<span class="sd">            tuple: area to include cells within, in the sense of distance from the origin along a direction.</span>
<span class="sd">            </span>
<span class="sd">        basis: determines if zone is given in cartesian (&#39;c&#39;) or direct (&#39;d&#39;) coordinates.</span>
<span class="sd">        IMPORTANT: If direct coordinates are used, use integers for zone, not float!</span>
<span class="sd">        </span>
<span class="sd">        norm_order: if zone is a number (=radius), norm_order is the norm to use (mathematical definition, see </span>
<span class="sd">        http://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.norm.html). Default is 2 (=Euclidean norm)</span>
<span class="sd">        Short version: 2 gives you a &quot;circle&quot;, numpy.inf a &quot;square&quot;.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">        Cells within 30 Angstrom:</span>
<span class="sd">        unitcells_within_zone(30)</span>
<span class="sd">        Cells within a 6x8x1 Angstrom cuboid:</span>
<span class="sd">        unitcells_within_zone((3.0,4.0,0.5))</span>
<span class="sd">        Cells within a 4x4x4 block in direct coordinates:</span>
<span class="sd">        unitcells_within_zone((2,2,2),&#39;d&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
                
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">zone</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">basis</span> <span class="o">==</span> <span class="s">&#39;d&#39;</span><span class="p">:</span>
                <span class="n">zone</span><span class="o">=</span><span class="nb">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">zone</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">basis</span> <span class="o">==</span> <span class="s">&#39;c&#39;</span><span class="p">:</span>
                <span class="n">reclattice_transposed_inverted</span><span class="o">=</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__latticevecs</span><span class="o">.</span><span class="n">reciprocal_latticevecs</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span> <span class="c">#matrix to transform from cartesian to direct coordinates</span>
                <span class="n">zone</span><span class="o">=</span><span class="nb">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">reclattice_transposed_inverted</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">zone</span><span class="p">)))</span>
            <span class="n">unitcellnrs</span><span class="o">=</span><span class="p">[</span><span class="n">unitcellnr</span> <span class="k">for</span> <span class="n">unitcellnr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__unitcellnumbers</span> <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">zone</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">unitcellnr</span><span class="p">))))</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">basis</span> <span class="o">==</span> <span class="s">&#39;c&#39;</span><span class="p">:</span>
                <span class="n">unitcellnrs</span><span class="o">=</span><span class="p">[</span><span class="n">unitcellnr</span> <span class="k">for</span> <span class="n">unitcellcoords</span><span class="p">,</span><span class="n">unitcellnr</span> 
                             <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unitcellcoordinates</span><span class="p">(),</span><span class="bp">self</span><span class="o">.</span><span class="n">__unitcellnumbers</span><span class="p">)</span> 
                             <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">unitcellcoords</span><span class="p">)</span><span class="o">&lt;=</span><span class="n">zone</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">basis</span> <span class="o">==</span> <span class="s">&#39;d&#39;</span><span class="p">:</span>    
                <span class="n">unitcellnrs</span><span class="o">=</span><span class="p">[</span><span class="n">unitcellnr</span> <span class="k">for</span> <span class="n">unitcellnr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__unitcellnumbers</span> <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">unitcellnr</span><span class="p">,</span><span class="n">norm_order</span><span class="p">)</span><span class="o">&lt;=</span><span class="n">zone</span><span class="p">]</span>
    
        <span class="k">return</span> <span class="n">unitcellnrs</span>
    </div>
<div class="viewcode-block" id="Hamiltonian.drop_dimension_from_cell_list"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.drop_dimension_from_cell_list">[docs]</a>    <span class="k">def</span> <span class="nf">drop_dimension_from_cell_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dimension</span><span class="p">,</span><span class="n">unitcellnumbers</span><span class="o">=</span><span class="s">&#39;all&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes a list of unit cell coordinates and drops the x,y or/and z dimension</span>
<span class="sd">        from the list - this way you can create a 2D material from a 3D material</span>
<span class="sd">        or a 1D material from a 2D material. The function deletes all unit cell numbers</span>
<span class="sd">        that have a nonzero entry in that dimension.</span>
<span class="sd">        </span>
<span class="sd">        dimension: the dimension to drop: 0, 1 or 2. Can also be a list, e.g. (0,1) drops</span>
<span class="sd">        the first and second dimension. </span>
<span class="sd">        unitcellnumbers: List of unit cell numbers. Default value is &#39;all&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">unitcellnumbers</span><span class="o">==</span><span class="s">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">unitcellnumbers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unitcellnumbers</span><span class="p">()</span>
            
        <span class="n">stack</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">unitcellnumbers</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">dimension</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">dimension</span><span class="o">=</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
            
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dimension</span><span class="p">:</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">stack</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="n">stack</span>
        
        

</div>
<div class="viewcode-block" id="Hamiltonian.hermitian_hoppinglist"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.hermitian_hoppinglist">[docs]</a>    <span class="k">def</span> <span class="nf">hermitian_hoppinglist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">unitcellnumbers</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The function removes unit cells from a list of unit cells whose &quot;parity</span>
<span class="sd">        partners&quot; are missing to ensure a Hermitian Bloch matrix.</span>
<span class="sd">        </span>
<span class="sd">        Return: kept, removed</span>
<span class="sd">        </span>
<span class="sd">        kept: Kept unit cell numbers</span>
<span class="sd">        removed: removed unit cell numbers (just for control purposes)</span>
<span class="sd">                </span>
<span class="sd">        If hopping to a specific unit cell is not used, one has to make sure</span>
<span class="sd">        that the parity inversed unit cell (=the cell with the &quot;negative&quot;</span>
<span class="sd">        coordinates&quot;) is also dropped.</span>
<span class="sd">        That&#39;s because the matrix elements of the bloch matrix look like this:</span>
<span class="sd">        </span>
<span class="sd">        ... + \gamma_i e^ikR + \gamma_i e^-ikR + ...</span>
<span class="sd">        </span>
<span class="sd">        The sum of the two terms is cos(ikR) and real.</span>
<span class="sd">        </span>
<span class="sd">        --&gt; The function drops the terms which miss their partner and thus won&#39;t</span>
<span class="sd">        become real.</span>
<span class="sd">        </span>
<span class="sd">        Note: It makes sense to remove not only the &quot;parity partner&quot;, but all unit</span>
<span class="sd">        cells which are identical due to symmetry.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">stack</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">unitcellnumbers</span><span class="p">)</span>
        <span class="n">kept</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">removed</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">element</span><span class="o">=</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">element</span> <span class="o">==</span> <span class="p">[</span><span class="o">-</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">element</span><span class="p">]:</span> <span class="c">#true for origin</span>
                <span class="n">kept</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">index_partner</span><span class="o">=</span><span class="n">stack</span><span class="o">.</span><span class="n">index</span><span class="p">([</span><span class="o">-</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">element</span><span class="p">])</span>
                    <span class="n">partner</span><span class="o">=</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index_partner</span><span class="p">)</span>
                    <span class="n">kept</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
                    <span class="n">kept</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">partner</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span> <span class="c">#raised if -element does not exist</span>
                    <span class="n">removed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">kept</span><span class="p">,</span><span class="n">removed</span>
       
            </div>
<div class="viewcode-block" id="Hamiltonian.unitcellnumbers"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.unitcellnumbers">[docs]</a>    <span class="k">def</span> <span class="nf">unitcellnumbers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the numbers of the unit cells supplied in the wannier90_hr.dat</span>
<span class="sd">        file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__unitcellnumbers</span><span class="p">)</span> <span class="c">#makes a copy instead of a reference</span>
    </div>
<div class="viewcode-block" id="Hamiltonian.nrorbitals"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.nrorbitals">[docs]</a>    <span class="k">def</span> <span class="nf">nrorbitals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of orbitals/bands.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nrbands</span>
    </div>
<div class="viewcode-block" id="Hamiltonian.standard_paths"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.standard_paths">[docs]</a>    <span class="k">def</span> <span class="nf">standard_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">nrpointspersegment</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gives the standard path for a Bravais lattice in</span>
<span class="sd">        direct reciprocal coordinates.</span>
<span class="sd">        </span>
<span class="sd">        At the moment, there are &#39;hexagonal&#39;, &#39;fcc&#39;, &#39;1D&#39; and &#39;1D-symmetric&#39;.</span>
<span class="sd">        </span>
<span class="sd">        name: Name of the lattice</span>
<span class="sd">        nrpointspersegment: optional; if &gt; 1, a list of intermediate points connecting</span>
<span class="sd">        the main points is also returned and can be used for a </span>
<span class="sd">        bandstructure path (nrpointspersegment points per segment).</span>
<span class="sd">        Default value: 100</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">        points,names(,path)</span>
<span class="sd">        </span>
<span class="sd">        points: points in the path</span>
<span class="sd">        names: names of the points</span>
<span class="sd">        (path: path with intermediate points. Only returned if nrpointspersegment is &gt; 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">==</span><span class="s">&#39;hexagonal&#39;</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">(</span><span class="s">&#39;G&#39;</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="p">(</span><span class="s">&#39;K&#39;</span><span class="p">,[</span><span class="mf">1.</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="p">(</span><span class="s">&#39;M&#39;</span><span class="p">,[</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="p">(</span><span class="s">&#39;G&#39;</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                    <span class="p">]</span>
        <span class="k">elif</span> <span class="n">name</span><span class="o">==</span><span class="s">&#39;fcc&#39;</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">(</span><span class="s">&#39;G&#39;</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="p">(</span><span class="s">&#39;X&#39;</span><span class="p">,[</span><span class="mf">1.</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mf">1.</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="p">(</span><span class="s">&#39;W&#39;</span><span class="p">,[</span><span class="mf">3.</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="mf">1.</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mf">1.</span><span class="o">/</span><span class="mi">4</span><span class="p">]),</span>
                    <span class="p">(</span><span class="s">&#39;L&#39;</span><span class="p">,[</span><span class="mf">1.</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mf">1.</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mf">1.</span><span class="o">/</span><span class="mi">2</span><span class="p">]),</span>
                    <span class="p">(</span><span class="s">&#39;G&#39;</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="p">(</span><span class="s">&#39;K&#39;</span><span class="p">,[</span><span class="mf">3.</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="mf">3.</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span><span class="mf">3.</span><span class="o">/</span><span class="mi">8</span><span class="p">])</span>
                    <span class="p">]</span>
        <span class="k">elif</span> <span class="n">name</span><span class="o">==</span><span class="s">&#39;1D&#39;</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">(</span><span class="s">&#39;G&#39;</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="p">(</span><span class="s">&#39;M&#39;</span><span class="p">,[</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>         
                    <span class="p">]</span>            
        <span class="k">elif</span> <span class="n">name</span><span class="o">==</span><span class="s">&#39;1D-symmetric&#39;</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">(</span><span class="s">&#39;M&#39;</span><span class="p">,[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>   
                    <span class="p">(</span><span class="s">&#39;G&#39;</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="p">(</span><span class="s">&#39;M&#39;</span><span class="p">,[</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                    <span class="p">]</span>                        
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Bravais lattice name not found!&quot;</span><span class="p">)</span>
            
        <span class="n">points</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">path</span><span class="p">]</span>
        <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">path</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">nrpointspersegment</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">point_path</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">nrpointspersegment</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">points</span><span class="p">,</span><span class="n">names</span><span class="p">,</span><span class="n">path</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">points</span><span class="p">,</span><span class="n">names</span>
        </div>
    <span class="k">def</span> <span class="nf">__orbital_spreads_and_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">wannier90_wout_filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads the final wannier90 orbital spreads and positions from the</span>
<span class="sd">        wannier90.wout file.</span>
<span class="sd">        </span>
<span class="sd">        wannier90_wout_filename: path to the wannier90.wout file.</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">        spreads,positions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c">#TODO: What about performance? Stuff gets copied pretty often</span>
        <span class="c">#maybe use this http://stackoverflow.com/a/4944929/1447622</span>
        
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">wannier90_wout_filename</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        
        <span class="n">splitspaces</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">]</span>
        <span class="c">#Catastrophe - only a Flatten[] command, but unreadable</span>
        <span class="n">infile</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">line</span><span class="p">]))</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">splitspaces</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="n">nr</span><span class="p">,</span><span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;Number of Wannier Functions&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ret</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
            
        <span class="n">nrbands</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">infile</span><span class="p">[</span><span class="n">nr</span><span class="p">][</span><span class="mi">6</span><span class="p">])</span>
        
        <span class="n">start</span> <span class="o">=</span> <span class="n">infile</span><span class="o">.</span><span class="n">index</span><span class="p">([</span><span class="s">&quot;Final&quot;</span><span class="p">,</span><span class="s">&quot;State&quot;</span><span class="p">])</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">infile</span><span class="p">[</span><span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">start</span><span class="o">+</span><span class="n">nrbands</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
        <span class="n">spreads</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">6</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">7</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">8</span><span class="p">])]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="n">spreads</span><span class="p">,</span><span class="n">positions</span>
    
    <span class="k">def</span> <span class="nf">__remove_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">seq</span><span class="p">):</span>
        <span class="c">#http://stackoverflow.com/questions/480214/how-do-you-remove-duplicates-from-a-list-in-python-whilst-preserving-order</span>
        <span class="c">#http://www.peterbe.com/plog/uniqifiers-benchmark (f2)</span>
        <span class="n">checked</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">e</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">checked</span><span class="p">:</span>
                <span class="n">checked</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">checked</span>        
    
<div class="viewcode-block" id="Hamiltonian.create_supercell_hamiltonian"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.create_supercell_hamiltonian">[docs]</a>    <span class="k">def</span> <span class="nf">create_supercell_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cellcoordinates</span><span class="p">,</span><span class="n">latticevecs</span><span class="p">,</span><span class="n">usedhoppingcells</span><span class="o">=</span><span class="s">&#39;all&#39;</span><span class="p">,</span><span class="n">usedorbitals</span><span class="o">=</span><span class="s">&#39;all&#39;</span><span class="p">,</span><span class="n">energyshift</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">magnetic_B</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">gauge_B</span><span class="o">=</span><span class="s">&#39;landau_x&#39;</span><span class="p">,</span><span class="n">mixin_ham</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">mixin_hoppings</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">mixin_cells</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">mixin_assoc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">onsite_potential</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">output_maincell_only</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates the matrix elements for a supercell containing several unit cells, e.g. a volume</span>
<span class="sd">        with one unit cell missing in the middle or one slice of a nanoribbon.</span>
<span class="sd">        </span>
<span class="sd">        cellcoordinates: unit cells contained in the supercell [[0,0,0],[1,0,0],...]. Use integergrid3d()</span>
<span class="sd">        to easily create a unit cell grid (which you can modify).</span>
<span class="sd">        latticevectors: lattice vectors of the new unit cell in the basis of the old unit cells (!!).</span>
<span class="sd">        E.g. a supercell of four graphene unit cells could have latticevecs=[[2,0,0],[0,2,0],[0,0,1]]. </span>
<span class="sd">        If you want to create a ribbon or a molecule, use a high value in one of the coordinates</span>
<span class="sd">        (e.g. a long y lattice vector).</span>
<span class="sd">        usedhoppingcells: If you don&#39;t want to use all hopping parameters, you can set the cells to &quot;hop&quot;</span>
<span class="sd">        to here (list of cell coordinates).</span>
<span class="sd">        usedorbitals: a list of orbitals to use. Default is &#39;all&#39;. Note: this only makes</span>
<span class="sd">        sense if the selected orbitals don&#39;t interact with other orbitals. </span>
<span class="sd">        energyshift: Shift energy scale by energyshift, e.g. to shift the Fermi energy to 0. Also shifts the Fermi</span>
<span class="sd">        energy variable of the Hamiltonian.</span>
<span class="sd">        magnetic_B: Magnetic field in perpendicular direction (in T)</span>
<span class="sd">        gauge_B: &#39;landau_x&#39;: Landau gauge for systems with x periodicity (A=(-By,0,0))</span>
<span class="sd">                 &#39;landau_y:&#39;: Landau gauge for systems with y periodicity (A=(0,Bx,0))</span>
<span class="sd">                 &#39;symmetric&#39;: Symmetric gauge for systems with x and y periodicity (A=1/2(-By,Bx,0))</span>
<span class="sd">        mixin_ham: A &quot;mix-in&quot; Hamiltonian from which some matrix elements are used. Default is None.</span>
<span class="sd">                   The mixin is done before the other modifications (magnetic field, energyshift)</span>
<span class="sd">        mixin_hoppings: A list of matrix elements from the main Hamiltonian that should be substituted with matrix elements from mixin_ham.</span>
<span class="sd">                        The conjugate hopping is generated automatically (i.e. (0,1) will be</span>
<span class="sd">                        automatically expanded to (0,1),(1,0) ). </span>
<span class="sd">                        Example: Substitute all matrix elements from orbitals 0,1 to orbitals 0,1,2,3:</span>
<span class="sd">                        mixin_hoppings=[(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3)]</span>
<span class="sd">        mixin_cells: List of unit cells. Substitution can be restricted to specific unit cells.</span>
<span class="sd">                     E.g. the main cell: mixin_cells=[[0,0,0]]</span>
<span class="sd">                     E.g. the main cell and the ones left and right: mixin_cells=[[-1,0,0],[0,0,0],[1,0,0]]</span>
<span class="sd">                     Default is None, which means that all cells that exist in both Hamiltonians will be substituted.</span>
<span class="sd">                     Mind that the cell coordinates have to be lists, not tuples!</span>
<span class="sd">        mixin_assoc: Association list for orbitals in the current Hamiltonian and the mixin Hamiltonian. Type is dictionary.</span>
<span class="sd">                     If the mixin Hamiltonian describes a different system, the orbital numbers may not be the same.</span>
<span class="sd">                     Only the relevant orbitals (those mentioned in mixin_hoppings) have to be here.</span>
<span class="sd">                     Default is None, which means that the orbital numbers are assumed to be identical.</span>
<span class="sd">                     Example:    Main Hamiltonian     Mixin Hamiltonian</span>
<span class="sd">                                 0                    0</span>
<span class="sd">                                 1                    1</span>
<span class="sd">                                 2                    2</span>
<span class="sd">                                 3                    3</span>
<span class="sd">                                 4                    4</span>
<span class="sd">                                 100                  15</span>
<span class="sd">                                 101                  16</span>
<span class="sd">                                 102                  17</span>
<span class="sd">                                 103                  18</span>
<span class="sd">                                 104                  19</span>
<span class="sd">                                 </span>
<span class="sd">                                 mixin_assoc={0:0,1:1,2:2,3:3,4:4,100:15,101:16,102:17,103:18,104:19}</span>
<span class="sd">        onsite_potential: List of numbers. The values will be added to the </span>
<span class="sd">        diagonal (=onsite) matrix elements of the main cell. This approximates</span>
<span class="sd">        an electrostatic potential in the system. Default is None.                         </span>
<span class="sd">        </span>
<span class="sd">        output_maincell_only: If True, only the main cell matrix block will be</span>
<span class="sd">        calculated. This makes sense for a big system of which you want to</span>
<span class="sd">        calculate the eigenvalues, not the bandstructure. Default is false</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">        New Hamiltonian with the new properties.</span>
<span class="sd">        &quot;&quot;&quot;</span>
                
        <span class="c">#TODO: Naming (numbers,positions,coordinates) is ambiguous</span>
        
        <span class="n">oldunitcellmatrixblocks</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__unitcellmatrixblocks</span>
        <span class="n">oldunitcellnumbers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__unitcellnumbers</span>
        <span class="n">oldorbitalpositions</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__orbitalpositions</span><span class="p">,</span><span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">oldorbitalspreads</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__orbitalspreads</span> <span class="c">#Must be List, not numpy array!</span>
        
        <span class="k">if</span> <span class="n">usedhoppingcells</span> <span class="o">==</span> <span class="s">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">usedunitcellnrs</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__unitcellnumbers</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">usedunitcellnrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__unitcellcoordinates_to_nrs</span><span class="p">(</span><span class="n">usedhoppingcells</span><span class="p">)</span>
        
        
        <span class="n">nr_unitcells_in_supercell</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">cellcoordinates</span><span class="p">)</span>   
        
        <span class="n">cellcoordinates_reverse_dict</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cellcoordinates</span><span class="p">):</span>
            <span class="n">cellcoordinates_reverse_dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">coord</span><span class="p">)]</span><span class="o">=</span><span class="n">i</span>
        
        <span class="n">unitcellmatrixblocks_dryctr</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">unitcellnumbers</span><span class="o">=</span><span class="p">[]</span>
        
        <span class="k">if</span> <span class="n">usedorbitals</span><span class="o">==</span><span class="s">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">orbitalnrs</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nrbands</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">orbitalnrs</span><span class="o">=</span><span class="n">usedorbitals</span>
            
        <span class="n">orbitals_per_unitcell</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">orbitalnrs</span><span class="p">)</span>
        
        <span class="c">#Set new orbital positions and spreads</span>
        <span class="n">oldunitcellcoordinates</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unitcellcoordinates</span><span class="p">(</span><span class="n">cellcoordinates</span><span class="p">)</span>
        <span class="n">orbitalspreads</span><span class="o">=</span><span class="p">[</span><span class="n">oldorbitalspreads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">orbitalnrs</span><span class="p">]</span><span class="o">*</span><span class="n">nr_unitcells_in_supercell</span> <span class="c">#Repeat oldorbitalspreads</span>
        <span class="c">#print oldunitcellcoordinates</span>
        <span class="c">#print oldorbitalpositions</span>
        <span class="n">orbitalpositions</span><span class="o">=</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">oldorbitalpositions</span><span class="p">[</span><span class="n">orb</span><span class="p">]</span><span class="o">+</span><span class="n">cell</span><span class="p">)</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">oldunitcellcoordinates</span> <span class="k">for</span> <span class="n">orb</span> <span class="ow">in</span> <span class="n">orbitalnrs</span><span class="p">]</span>
        
        <span class="n">metric_numerator</span><span class="p">,</span><span class="n">metric_denominator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__metric</span><span class="p">(</span><span class="n">latticevecs</span><span class="p">)</span>
        <span class="n">latticevecs_dot_metric_numerator</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">latticevecs</span><span class="p">,</span><span class="n">metric_numerator</span><span class="p">)</span>
        <span class="c">#Loop over cells in supercell</span>
        
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Besser: zuerst alle indizes/positionen aufstellen, dann mit sparse.bmat die matrix zusammenbauen.</span>
<span class="sd">        Andere fkten auch aktualisieren!!</span>
<span class="sd">        </span>
<span class="sd">        ...und auch mal mixins und connections zw. bauteilen (kleben) verbessern. vl wie elektrostatik-kleben?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cellnr</span><span class="p">,</span><span class="n">cell</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cellcoordinates</span><span class="p">)):</span>
            <span class="c">#Loop over old blocks</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">oldnumber</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">oldunitcellmatrixblocks</span><span class="p">)),</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">oldunitcellnumbers</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">usedunitcellnrs</span><span class="p">:</span>                        
                    <span class="n">hopto</span><span class="o">=</span><span class="n">cell</span><span class="o">+</span><span class="n">oldnumber</span>
                    
                    <span class="n">hopto_scaled_times_metric_denominator</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">latticevecs_dot_metric_numerator</span><span class="p">,</span><span class="n">hopto</span><span class="p">)</span>
                    <span class="n">hopto_scaled</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">hopto_scaled_times_metric_denominator</span><span class="o">/</span><span class="n">metric_denominator</span><span class="p">)</span>
                    <span class="n">hopto_rest_times_metric_denominator</span><span class="o">=</span><span class="n">hopto_scaled_times_metric_denominator</span><span class="o">%</span><span class="n">metric_denominator</span>
                    <span class="n">hopto_nr</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hopto_rest_times_metric_denominator</span><span class="p">,</span><span class="n">latticevecs</span><span class="p">)</span><span class="o">/</span><span class="n">metric_denominator</span><span class="p">)</span>
                    
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">skip_block</span><span class="o">=</span><span class="bp">False</span>
                        <span class="n">hopto_nr_index</span><span class="o">=</span><span class="n">cellcoordinates_reverse_dict</span><span class="p">[</span><span class="n">hopto_nr</span><span class="p">]</span><span class="c">#cellcoordinates.index(hopto_nr) </span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="n">skip_block</span><span class="o">=</span><span class="bp">True</span> <span class="c">#if the cell to hop to is not in the cellcoordinates list, the block is skipped</span>
                        
                    <span class="k">if</span> <span class="n">output_maincell_only</span> <span class="ow">and</span> <span class="n">hopto_scaled</span><span class="o">!=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">skip_block</span><span class="o">=</span><span class="bp">True</span>
                    
                    <span class="k">if</span> <span class="n">skip_block</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>                        
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">unitcellindex</span><span class="o">=</span><span class="n">unitcellnumbers</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">hopto_scaled</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                            <span class="n">unitcellindex</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">unitcellnumbers</span><span class="p">)</span>
                            <span class="n">unitcellnumbers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hopto_scaled</span><span class="p">)</span>
                            <span class="n">unitcellmatrixblocks_dryctr</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                        
                        <span class="c">#unitcellmatrixblocks[unitcellindex][cellnr*orbitals_per_unitcell:(cellnr+1)*orbitals_per_unitcell,</span>
                        <span class="c">#                                    hopto_nr_index*orbitals_per_unitcell:(hopto_nr_index+1)*orbitals_per_unitcell]=oldblock_selectedorbitals</span>
                        <span class="n">unitcellmatrixblocks_dryctr</span><span class="p">[</span><span class="n">unitcellindex</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">cellnr</span><span class="p">,</span><span class="n">hopto_nr_index</span><span class="p">])</span>
        
        <span class="n">oldlatticevecs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__latticevecs</span><span class="o">.</span><span class="n">latticevecs</span><span class="p">()</span>
        <span class="n">newlatticevecs</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">latticevecs</span><span class="p">),</span><span class="n">oldlatticevecs</span><span class="p">)</span> <span class="c"># (A.B)&#39;=B&#39;.A&#39; - new latticevectors in real coordinates</span>
                        
        
        <span class="k">if</span> <span class="n">usedorbitals</span><span class="o">==</span><span class="s">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">oldblocks_selectedorbitals</span><span class="o">=</span><span class="n">oldunitcellmatrixblocks</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c">#the conversion to csr is annoying, but necessary</span>
            <span class="c">#oldblocks_selectedorbitals=[block.tocsr()[numpy.array(orbitalnrs)[:,numpy.newaxis],numpy.array(orbitalnrs)] for block in oldunitcellmatrixblocks]</span>
            <span class="n">oldblocks_selectedorbitals</span><span class="o">=</span><span class="p">[</span><span class="n">block</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()[</span><span class="n">orbitalnrs</span><span class="p">,:][:,</span><span class="n">orbitalnrs</span><span class="p">]</span> <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">oldunitcellmatrixblocks</span><span class="p">]</span>
        
        <span class="n">unitcellmatrixblocks_sparse</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">emptyblock</span><span class="o">=</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">orbitals_per_unitcell</span><span class="p">,</span><span class="n">orbitals_per_unitcell</span><span class="p">))</span> <span class="c">#placeholder for empty blocks; coo is much faster than lil. Better understanding may lead to improvements</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">cell</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unitcellmatrixblocks_dryctr</span><span class="p">):</span>
            <span class="n">unitcellmatrixblocks_sparse_template</span><span class="o">=</span> <span class="p">[</span> <span class="p">[</span> <span class="n">emptyblock</span> <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="n">j</span> <span class="k">else</span> <span class="bp">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr_unitcells_in_supercell</span><span class="p">)</span> <span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr_unitcells_in_supercell</span><span class="p">)</span> <span class="p">]</span>
            <span class="k">for</span> <span class="n">block</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">cell</span><span class="p">:</span>
                <span class="n">unitcellmatrixblocks_sparse_template</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">oldblocks_selectedorbitals</span><span class="p">[</span><span class="n">block</span><span class="p">]</span>
            <span class="n">unitcellmatrixblocks_sparse</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sparse</span><span class="o">.</span><span class="n">bmat</span><span class="p">(</span><span class="n">unitcellmatrixblocks_sparse_template</span><span class="p">))</span>
           
           
        <span class="c">#Mix in matrix elements from other hamiltonian</span>
        <span class="k">if</span> <span class="n">mixin_ham</span><span class="o">!=</span><span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
            <span class="n">othermatrixblocks</span><span class="o">=</span><span class="n">mixin_ham</span><span class="o">.</span><span class="n">_Hamiltonian__unitcellmatrixblocks</span>
            <span class="n">otherunitcellnumbers</span><span class="o">=</span><span class="n">mixin_ham</span><span class="o">.</span><span class="n">unitcellnumbers</span><span class="p">()</span>
            
            <span class="n">myhoppingelements</span><span class="o">=</span><span class="n">mixin_hoppings</span><span class="o">+</span><span class="p">[(</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">mixin_hoppings</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">mixin_assoc</span><span class="o">==</span><span class="bp">None</span><span class="p">:</span>
                <span class="n">otherhoppingelements</span><span class="o">=</span><span class="n">myhoppingelements</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">otherhoppingelements</span><span class="o">=</span><span class="p">[(</span><span class="n">mixin_assoc</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">mixin_assoc</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">myhoppingelements</span><span class="p">]</span>
                
            <span class="k">for</span> <span class="n">mycellidx</span><span class="p">,</span><span class="n">mycellnr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unitcellnumbers</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">mycellnr</span> <span class="ow">in</span> <span class="n">otherunitcellnumbers</span> <span class="ow">and</span> <span class="p">(</span><span class="n">mixin_cells</span><span class="o">==</span><span class="bp">None</span> <span class="ow">or</span> <span class="n">mycellnr</span> <span class="ow">in</span> <span class="n">mixin_cells</span><span class="p">):</span>
                    <span class="n">othercellidx</span><span class="o">=</span><span class="n">otherunitcellnumbers</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">mycellnr</span><span class="p">)</span>
                    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">),(</span><span class="n">k</span><span class="p">,</span><span class="n">l</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">myhoppingelements</span><span class="p">,</span><span class="n">otherhoppingelements</span><span class="p">):</span>
                        <span class="n">unitcellmatrixblocks</span><span class="p">[</span><span class="n">mycellidx</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">othermatrixblocks</span><span class="p">[</span><span class="n">othercellidx</span><span class="p">][</span><span class="n">k</span><span class="p">,</span><span class="n">l</span><span class="p">]</span>
                        

        <span class="c">#Add onsite potential = electrostatic potential</span>
        <span class="k">if</span> <span class="n">onsite_potential</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c">#XXX: sparse.lil_matrix(numpy.diag(... is a weird construction</span>
            <span class="c">#XXX: the conversion to lil_matrix _may_ be a bottleneck</span>
            <span class="c">#main cell block is converted to lil_matrix!             </span>
            <span class="n">unitcellmatrixblocks_sparse</span><span class="p">[</span><span class="n">unitcellnumbers</span><span class="o">.</span><span class="n">index</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])]</span><span class="o">=</span><span class="n">unitcellmatrixblocks_sparse</span><span class="p">[</span><span class="n">unitcellnumbers</span><span class="o">.</span><span class="n">index</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])]</span><span class="o">.</span><span class="n">tolil</span><span class="p">()</span><span class="o">+</span><span class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">onsite_potential</span><span class="p">))</span>   
                        
        <span class="c">#Shift diagonal elements of main cell hopping block</span>
        <span class="k">if</span> <span class="n">energyshift</span><span class="o">!=</span><span class="bp">None</span><span class="p">:</span>        
            <span class="c">#XXX: sparse.lil_matrix(numpy.diag(... is a weird construction</span>
            <span class="c">#main cell block is converted to lil_matrix!             </span>
            <span class="n">unitcellmatrixblocks_sparse</span><span class="p">[</span><span class="n">unitcellnumbers</span><span class="o">.</span><span class="n">index</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])]</span><span class="o">=</span><span class="n">unitcellmatrixblocks_sparse</span><span class="p">[</span><span class="n">unitcellnumbers</span><span class="o">.</span><span class="n">index</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])]</span><span class="o">.</span><span class="n">tolil</span><span class="p">()</span><span class="o">+</span><span class="n">sparse</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">((</span><span class="n">orbitals_per_unitcell</span><span class="o">*</span><span class="n">nr_unitcells_in_supercell</span><span class="p">)</span><span class="o">*</span><span class="p">[</span><span class="n">energyshift</span><span class="p">]))</span>
        
    
        <span class="c">#Apply magnetic field</span>
        <span class="c">#distances_in_unit_cell=numpy.array([[x-y for x in numpy.array(orbitalpositions)] for y in numpy.array(orbitalpositions)])</span>
        <span class="k">if</span> <span class="n">magnetic_B</span><span class="o">!=</span><span class="bp">None</span><span class="p">:</span>        
            <span class="n">Tesla_conversion_factor</span><span class="o">=</span><span class="mf">1.602176487</span><span class="o">/</span><span class="mf">1.0545717</span><span class="o">*</span><span class="mf">1e-5</span>
            <span class="c">#print Tesla_conversion_factor</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">number</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unitcellnumbers</span><span class="p">):</span>
                <span class="n">unitcellcoordinates</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">number</span><span class="p">,</span><span class="n">newlatticevecs</span><span class="p">)</span>
                <span class="n">othercell_orbitalpositions</span><span class="o">=</span><span class="p">[</span><span class="n">unitcellcoordinates</span><span class="o">+</span><span class="n">orb</span> <span class="k">for</span> <span class="n">orb</span> <span class="ow">in</span> <span class="n">orbitalpositions</span><span class="p">]</span>
                <span class="c">#distances=distances_in_unit_cell+unitcellcoordinates #distances[i][j]=Distance from orb i in main cell to orb j in other cell</span>
                <span class="c">#print othercell_orbitalpositions</span>
                <span class="k">if</span> <span class="n">gauge_B</span><span class="o">==</span><span class="s">&#39;landau_x&#39;</span><span class="p">:</span>
                    <span class="n">phasematrix</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">magnetic_B</span><span class="o">*</span><span class="n">Tesla_conversion_factor</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">main</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">main</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">othercell_orbitalpositions</span><span class="p">]</span> <span class="k">for</span> <span class="n">main</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">orbitalpositions</span><span class="p">)]))</span>
                <span class="k">if</span> <span class="n">gauge_B</span><span class="o">==</span><span class="s">&#39;landau_y&#39;</span><span class="p">:</span>
                    <span class="n">phasematrix</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">magnetic_B</span><span class="o">*</span><span class="n">Tesla_conversion_factor</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">main</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">main</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">othercell_orbitalpositions</span><span class="p">]</span> <span class="k">for</span> <span class="n">main</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">orbitalpositions</span><span class="p">)]))</span>
                <span class="k">if</span> <span class="n">gauge_B</span><span class="o">==</span><span class="s">&#39;symmetric&#39;</span><span class="p">:</span>
                    <span class="n">phasematrix</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">magnetic_B</span><span class="o">*</span><span class="n">Tesla_conversion_factor</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="o">*</span><span class="p">((</span><span class="n">other</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">main</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">main</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">main</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">main</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">othercell_orbitalpositions</span><span class="p">]</span> <span class="k">for</span> <span class="n">main</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">orbitalpositions</span><span class="p">)]))</span>
                <span class="c">#XXX: matrices are implicitly converted to numpy arrays. Make phasematrix a sparse matrix.</span>
                <span class="n">unitcellmatrixblocks_sparse</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(</span><span class="n">unitcellmatrixblocks_sparse</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">phasematrix</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">energyshift</span> <span class="o">!=</span> <span class="bp">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fermi_energy</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">newfermi_energy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__fermi_energy</span><span class="o">+</span><span class="n">energyshift</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newfermi_energy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__fermi_energy</span>
            
        <span class="c">#unitcellmatrixblocks_csr=[block.tocsr() for block in unitcellmatrixblocks_sparse]</span>
      
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_raw_data</span><span class="p">(</span><span class="n">unitcellmatrixblocks_sparse</span><span class="p">,</span> <span class="n">unitcellnumbers</span><span class="p">,</span> <span class="n">newlatticevecs</span><span class="p">,</span><span class="n">orbitalspreads</span><span class="p">,</span><span class="n">orbitalpositions</span><span class="p">,</span><span class="n">newfermi_energy</span><span class="p">)</span>
        <span class="c">#return unitcellmatrixblocks</span>
    </div>
    <span class="k">def</span> <span class="nf">__metric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">basis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the metric for a given basis using the formula</span>
<span class="sd">        Inverse[basis].Inverse[Transpose[basis]].</span>
<span class="sd">        </span>
<span class="sd">        basis: 3x3 matrix, containing the basis vectors in rows.</span>
<span class="sd">        </span>
<span class="sd">        Return:        </span>
<span class="sd">        metric_numerator: The numerator of the metric (3x3 matrix)</span>
<span class="sd">        metric_denominator: The denominator - a scalar because it is identical for all elements.</span>
<span class="sd">        </span>
<span class="sd">        The metric is 1/metric_denominator * metric_numerator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">b</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
        
        <span class="n">metric_denominator</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                          <span class="o">+</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                          <span class="o">+</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
                          <span class="o">-</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
                          <span class="o">-</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
                          <span class="o">+</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
        
        <span class="n">metric_numerator</span><span class="o">=</span><span class="p">[</span>
                            <span class="p">[</span>
                            <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                            <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]),</span>
                            <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
                            <span class="p">],[</span>
                            <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]),</span>
                            <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                            <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
                            <span class="p">],[</span>
                            <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]),</span>
                            <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]),</span>
                            <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
                            <span class="p">]</span>
                            <span class="p">]</span>
        
        <span class="k">return</span> <span class="n">metric_numerator</span><span class="p">,</span><span class="n">metric_denominator</span>   
        
        
        
    
    <span class="k">def</span> <span class="nf">__absolute_ceiling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rounds to the next integer value that has the greater absolute value.</span>
<span class="sd">        </span>
<span class="sd">        1.5 -&gt; 2</span>
<span class="sd">        -1.5 -&gt; -2 </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">))</span> 
    
<div class="viewcode-block" id="Hamiltonian.create_modified_hamiltonian"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.create_modified_hamiltonian">[docs]</a>    <span class="k">def</span> <span class="nf">create_modified_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">usedhoppingcells</span><span class="o">=</span><span class="s">&#39;all&#39;</span><span class="p">,</span><span class="n">usedorbitals</span><span class="o">=</span><span class="s">&#39;all&#39;</span><span class="p">,</span><span class="n">energyshift</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">magnetic_B</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">gauge_B</span><span class="o">=</span><span class="s">&#39;landau_x&#39;</span><span class="p">,</span><span class="n">mixin_ham</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">mixin_hoppings</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">mixin_cells</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">mixin_assoc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">onsite_potential</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a Hamiltonian with dropped orbitals or hopping cells. This is just a wrapper for </span>
<span class="sd">        create_supercell_hamiltonian().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_supercell_hamiltonian</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">usedhoppingcells</span><span class="p">,</span> <span class="n">usedorbitals</span><span class="p">,</span><span class="n">energyshift</span><span class="p">,</span><span class="n">magnetic_B</span><span class="p">,</span><span class="n">gauge_B</span><span class="p">,</span><span class="n">mixin_ham</span><span class="p">,</span><span class="n">mixin_hoppings</span><span class="p">,</span><span class="n">mixin_cells</span><span class="p">,</span><span class="n">mixin_assoc</span><span class="p">,</span><span class="n">onsite_potential</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Hamiltonian.apply_electrostatic_potential"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.apply_electrostatic_potential">[docs]</a>    <span class="k">def</span> <span class="nf">apply_electrostatic_potential</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">potential</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply an electrostatic potential to the system and return the new</span>
<span class="sd">        Hamiltonian.</span>
<span class="sd">        </span>
<span class="sd">        potential: a LinearInterpolationNOGrid object. If the object is a 1D/2D</span>
<span class="sd">        interpolation, the y and z/z coordinate are not used.</span>
<span class="sd">        </span>
<span class="sd">        Don&#39;t forget to match the unit of length and potential!</span>
<span class="sd">        </span>
<span class="sd">        Best function yet in OOP.</span>
<span class="sd">        </span>
<span class="sd">        Very Pythonic: potential can be anything with ().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">dim</span><span class="o">=</span><span class="n">potential</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span>
        
        <span class="n">points</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__orbitalpositions</span><span class="p">)[:,:</span><span class="n">dim</span><span class="p">]</span>
        <span class="n">potential</span><span class="o">=</span><span class="n">potential</span><span class="o">.</span><span class="n">map_function_to_points</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_modified_hamiltonian</span><span class="p">(</span><span class="n">onsite_potential</span><span class="o">=</span><span class="n">potential</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="Hamiltonian.shift_fermi_energy_to_zero"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.shift_fermi_energy_to_zero">[docs]</a>    <span class="k">def</span> <span class="nf">shift_fermi_energy_to_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies an energy shift so that the new Fermi energy is at 0.</span>
<span class="sd">        </span>
<span class="sd">        The new Hamiltonian is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_modified_hamiltonian</span><span class="p">(</span><span class="n">energyshift</span><span class="o">=-</span><span class="bp">self</span><span class="o">.</span><span class="n">fermi_energy</span><span class="p">())</span>
    </div>
<div class="viewcode-block" id="Hamiltonian.integergrid3d"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.Hamiltonian.integergrid3d">[docs]</a>    <span class="k">def</span> <span class="nf">integergrid3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an integer grid with the dimensions i,j,k</span>
<span class="sd">        &quot;&quot;&quot;</span>
    
        <span class="k">return</span> <span class="p">[[</span><span class="n">ii</span><span class="p">,</span><span class="n">jj</span><span class="p">,</span><span class="n">kk</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
</div></div>
<div class="viewcode-block" id="BandstructurePlot"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.BandstructurePlot">[docs]</a><span class="k">class</span> <span class="nc">BandstructurePlot</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Combine several bandstructure plots.</span>
<span class="sd">    </span>
<span class="sd">    Call plot(kpoints,data) for every bandstructure plot.</span>
<span class="sd">    Then, call save(filename) to save to a file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<span class="c">#    __stylelist=[&#39;b-&#39;,&#39;g-&#39;,&#39;r-&#39;,&#39;c-&#39;,&#39;m-&#39;,&#39;y-&#39;,&#39;k-&#39;]</span>
<span class="c">#    __plotcounter=0</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>    
        
    <span class="k">def</span> <span class="nf">__kpoints_to_pathlength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">points</span><span class="p">):</span>       
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        points: list of points</span>
<span class="sd">        </span>
<span class="sd">        Calculates the distance from the first point to each point in the list along the path.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">points</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">distances</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">distance</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">prev</span><span class="p">,</span><span class="n">this</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">points</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">distance</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">this</span><span class="o">-</span><span class="n">prev</span><span class="p">)</span><span class="o">+</span><span class="n">distance</span>
            <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">distances</span>
    
<span class="c">#    def set_aspect_ratio(self,aspect):</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        Set the aspect ratio. For possible values, see</span>
<span class="c">#        http://matplotlib.sourceforge.net/api/axes_api.html#matplotlib.axes.Axes.set_aspect</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        ax = pyplot.gca()</span>
<span class="c">#        ax.set_aspect(aspect)</span>
    
<span class="c">#    def set_plot_range(self,**kwargs):</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        Set the plot range using the kwargs</span>
<span class="c">#        xmin, xmax, ymin, ymax.</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#</span>
<span class="c">#        #http://matplotlib.sourceforge.net/api/pyplot_api.html#matplotlib.pyplot.axis</span>
<span class="c">#        </span>
<span class="c">#        pyplot.figure(self.__myplot.number)</span>
<span class="c">#        pyplot.axis(**kwargs)</span>
        
        <span class="c">#ax = pyplot.gca()</span>
        <span class="c">#ax.set_autoscale_on(False)</span>
        
    
<div class="viewcode-block" id="BandstructurePlot.plot"><a class="viewcode-back" href="../../../wannier90.html#envtb.wannier90.w90hamiltonian.BandstructurePlot.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">kpoints</span><span class="p">,</span><span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a bandstructure plot to the figure.</span>
<span class="sd">        </span>
<span class="sd">        kpoints: list of kpoints</span>
<span class="sd">        data: list of eigenvalues for each kpoint.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        At the beginning, the figure is set to __myplot which was set in the constructor</span>
<span class="c">#        to avoid interference between plot functions.</span>
<span class="c">#        http://stackoverflow.com/questions/7986567/matplotlib-how-to-set-the-current-figure/7987462#7987462</span>
<span class="c">#        &quot;&quot;&quot;</span>

        <span class="n">pathlength</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__kpoints_to_pathlength</span><span class="p">(</span><span class="n">kpoints</span><span class="p">)</span>
<span class="c">#        if style == &#39;auto&#39;:</span>
<span class="c">#            stylestring=self.__stylelist[self.__plotcounter % len(self.__stylelist)]</span>
<span class="c">#        else:</span>
<span class="c">#            stylestring=style</span>
            
<span class="c">#        self.__plotcounter+=1</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">pyplot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pathlength</span><span class="p">,</span><span class="n">band</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">band</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">transpose</span><span class="p">()]</span>
            </div>
    <span class="k">def</span> <span class="nf">plot_fermi_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fermi_energy</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">pyplot</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">fermi_energy</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s">&#39;r&#39;</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">plot_lattice_point_vlines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">reclatticepoints</span><span class="p">,</span><span class="n">reclatticenames</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">positions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__kpoints_to_pathlength</span><span class="p">(</span><span class="n">reclatticepoints</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">reclatticenames</span><span class="o">!=</span><span class="bp">None</span><span class="p">:</span>
            <span class="n">pyplot</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span> <span class="n">positions</span><span class="p">,</span> <span class="n">reclatticenames</span> <span class="p">)</span>
            
        <span class="k">return</span> <span class="p">[</span><span class="n">pyplot</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span><span class="n">dashes</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span><span class="n">color</span><span class="o">=</span><span class="s">&#39;#AAAAAA&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">]</span>
            
    
<span class="c">#    def save(self,filename):</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        Save the figure to a file. The format is determined</span>
<span class="c">#        by the filename.</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        pyplot.savefig(filename,dpi=(150))</span>
        
<span class="c">#    def reset(self):</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        Clear the current figure.</span>
<span class="c">#        &quot;&quot;&quot;</span>
<span class="c">#        pyplot.clf()</span>
        
<span class="c">#    def show(self):</span>
<span class="c">#        pyplot.show()</span>
    

    </div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">EnvTB 1 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Rafael Reiter.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>